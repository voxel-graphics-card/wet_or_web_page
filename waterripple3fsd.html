<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Water Ripple Effect (Mobile Optimized)</title>
    <style>
        /* Universal reset for margin, padding, and box-sizing */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Body styling for full viewport coverage and background gradient */
        body {
            background: linear-gradient(135deg, #0a0f1c, #1a1f2e);
            overflow: hidden; /* Prevents scrollbars from canvas or other elements */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            transition: background 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: none; /* Hides default cursor by default */
            width: 100vw; /* Ensures body takes full viewport width */
            height: 100vh; /* Ensures body takes full viewport height */
            position: relative; /* Establishes positioning context for absolute children */
        }

        /* New class to show default cursor on body */
        body.show-default-cursor {
            cursor: default !important; /* Override cursor: none */
        }

        /* Canvas styling to fill the entire screen */
        canvas {
            display: block;
            background: radial-gradient(ellipse at center, rgba(26, 35, 50, 0.4) 0%, rgba(13, 17, 23, 0.8) 100%);
            transition: background 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            position: fixed; /* Positions canvas relative to the viewport */
            top: 0;
            left: 0;
            width: 100vw; /* CSS width to fill the viewport */
            height: 100vh; /* CSS height to fill the viewport */
            z-index: 1; /* Places canvas at the lowest visual layer */
        }

        /* UI Overlay container for all interactive elements */
        .ui-overlay {
            position: fixed; /* Overlays the entire viewport */
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none; /* Allows mouse events to pass through its background to the canvas */
            z-index: 10; /* Places UI elements above the canvas */
            display: flex; /* Use flexbox for layout */
            flex-direction: column; /* Stack children vertically */
            align-items: flex-start; /* Align items to the start (left) */
            padding: 24px; /* Global padding for UI elements */
            gap: 20px; /* Space between flex items */
        }

        /* Re-enable pointer events for specific interactive elements within the UI overlay */
        .info, .menu-container, .story-overlay, .performance-stats {
            pointer-events: auto;
        }

        /* Info box styling */
        .info {
            color: rgba(225, 230, 234, 0.9);
            font-size: 13px;
            font-weight: 500;
            text-shadow: 0 2px 8px rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.08);
            padding: 12px 16px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            z-index: 20; /* Ensures info is above other UI elements if overlapping */
            align-self: flex-start; /* Align to the start of the flex container */
            margin-right: auto; /* Push it to the left */
        }

        /* Menu container for the dropdown */
        .menu-container {
            position: absolute;
            top: 24px;
            right: 24px;
            left: auto;
            transform: none;
            z-index: 20;
        }

        /* Menu button styling */
        .menu-button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: white;
            padding: 10px 18px;
            border-radius: 24px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            backdrop-filter: blur(20px);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            user-select: none;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .menu-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .menu-button:hover {
            background: rgba(255, 255, 255, 0.18);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }

        .menu-button:active {
            transform: translateY(0);
        }

        /* Dropdown content styling */
        .dropdown-content {
            display: none;
            position: absolute;
            top: 60px;
            right: 0;
            left: auto;
            transform: none;
            background: rgba(10, 15, 28, 0.9);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 15px;
            flex-direction: column;
            gap: 10px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.6);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-out, visibility 0.3s ease-out;
            min-width: 150px;
        }

        .dropdown-content.show {
            display: flex;
            opacity: 1;
            visibility: visible;
        }

        /* Style for buttons inside the dropdown */
        .dropdown-content .control-btn,
        .dropdown-content .music-toggle-btn {
            width: 100%;
            padding: 12px 15px;
            font-size: 14px;
            border-radius: 18px;
            background: rgba(255, 255, 255, 0.1);
        }

        .dropdown-content .control-btn:hover,
        .dropdown-content .music-toggle-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(0);
            box-shadow: none;
        }

        /* Story overlay styling for text content */
        .story-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: min(90%, 800px);
            max-height: 85vh;
            color: rgba(225, 230, 234, 0.95);
            font-size: clamp(0.9rem, 2vw, 1.1rem);
            line-height: 1.7;
            text-align: center;
            text-shadow: 0 2px 12px rgba(0,0,0,0.9);
            padding: 32px;
            background: rgba(0, 0, 0, 0.25);
            border-radius: 20px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.3) transparent;
            z-index: 15;
            padding-top: 50px;
        }

        /* Story overlay close button */
        .story-overlay .close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 20px;
            font-weight: bold;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.3s ease;
            line-height: 1;
        }

        .story-overlay .close-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Webkit scrollbar styling for story overlay */
        .story-overlay::-webkit-scrollbar {
            width: 6px;
        }

        .story-overlay::-webkit-scrollbar-track {
            background: transparent;
        }

        .story-overlay::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
        }

        /* Story overlay heading styling */
        .story-overlay h1 {
            font-size: clamp(1.5rem, 4vw, 2.2rem);
            margin-bottom: 24px;
            font-weight: 700;
            background: linear-gradient(135deg, #e1e6ea, #a0c4ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Story overlay paragraph styling */
        .story-overlay p {
            margin-bottom: 20px;
            text-align: justify;
        }

        /* Custom cursor styling */
        .custom-cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            transition: all 0.1s ease;
            backdrop-filter: blur(2px);
        }

        /* New class to hide the custom cursor */
        .custom-cursor.hidden {
            display: none;
        }

        /* Performance stats display */
        .performance-stats {
            color: rgba(255, 255, 255, 0.7);
            font-size: 11px;
            font-family: 'Courier New', monospace;
            background: rgba(0, 0, 0, 0.1);
            padding: 8px 12px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            display: none; /* Hidden by default, toggled by button */
            z-index: 9; /* Ensures stats are above other UI elements but behind the options or controls */
            /* New positioning for bottom center */
            position: absolute;
            bottom: 24px; /* Aligned with UI overlay padding */
            left: 50%;
            transform: translateX(-50%);
            margin-top: 0; /* Remove previous flex alignment margin */
        }

        /* Light theme specific styles */
        .light-theme {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .light-theme canvas {
            background: radial-gradient(ellipse at center, rgba(102, 126, 234, 0.3) 0%, rgba(118, 75, 162, 0.6) 100%);
        }

        /* Responsive adjustments for smaller screens (max-width: 768px - typical tablet portrait) */
        @media (max-width: 768px) {
            .ui-overlay {
                padding: 15px; /* Reduce global padding */
                gap: 15px; /* Reduce gap between elements */
                align-items: center; /* Center items for a cleaner mobile layout */
            }

            .info {
                font-size: 11px;
                padding: 10px 14px;
                align-self: center; /* Center the info box */
                text-align: center;
                margin-left: 0; /* Remove left margin */
            }

            .story-overlay {
                width: 95%;
                padding: 24px 20px;
                max-height: 80vh;
                font-size: clamp(0.85rem, 2.5vw, 1rem); /* Slightly smaller font for paragraphs */
                padding-top: 50px; /* Ensure space for close button */
            }

            .story-overlay h1 {
                font-size: clamp(1.4rem, 5vw, 2rem); /* Adjust heading size for mobile */
            }

            .menu-button {
                padding: 10px 16px; /* Slightly larger padding for easier tapping */
                font-size: 13px; /* Slightly larger font size */
                min-width: 120px; /* Ensure buttons have a minimum tap area */
            }

            .menu-container {
                top: 15px; /* Adjusted: top for mobile */
                right: 15px; /* Adjusted: right for mobile */
                bottom: auto; /* Reset bottom */
                left: auto; /* Reset left */
            }

            .dropdown-content {
                top: 60px; /* Adjust dropdown position relative to new menu button position */
                right: 0; /* Align to the right of the menu button */
                left: auto; /* Reset left */
                bottom: auto; /* Reset bottom */
            }

            .performance-stats {
                font-size: 10px;
                padding: 6px 10px;
                /* Adjusted: bottom for mobile */
                bottom: 15px; /* Aligned with UI overlay padding */
                left: 50%;
                transform: translateX(-50%);
                margin-top: 0; /* Remove flex alignment margin */
            }
        }

        /* Smallest screens (e.g., iPhone SE) */
        @media (max-width: 480px) {
            .story-overlay {
                padding: 15px;
                font-size: 0.8rem;
                line-height: 1.6;
            }

            .story-overlay h1 {
                margin-bottom: 15px;
            }

            .info {
                padding: 8px 12px;
                font-size: 10px;
            }

            .menu-button {
                padding: 8px 12px;
                font-size: 12px;
                min-width: unset; /* Allow smaller width if content wraps */
                flex-grow: 1; /* Allow buttons to grow and fill space */
            }

            .menu-container {
                top: 10px; /* Further adjust for very small screens */
                right: 10px; /* Further adjust for very small screens */
            }

            .dropdown-content {
                gap: 5px; /* Adjusted: Even smaller gap for buttons in dropdown */
                top: 55px; /* Adjust dropdown position relative to new menu button position */
            }

            .performance-stats {
                font-size: 9px;
                /* Adjusted: bottom for very small screens */
                bottom: 10px; /* Aligned with UI overlay padding */
            }
        }
    </style>
</head>
<body>
    <canvas id="waterCanvas"></canvas>

    <div class="ui-overlay">
        <div class="info">
            <div>Move cursor/finger to create ripples</div>
            <div>Click/tap for powerful waves</div>
        </div>

        <div class="story-overlay">
            <button class="close-btn" id="closeStoryOverlay">X</button>
            <h1>Welcome to the Literature Club!</h1>
            <p>The gentle patter of rain against the windowpane seemed to echo the quiet hum of the classroom after hours. You, a new member, stepped into the vibrant world of the Literature Club, drawn by the promise of friendship and shared passions. Sayori, with her bright, infectious smile, was the first to greet you, her laughter a melody in the otherwise hushed halls.</p>

            <p>Soon, you met the others: Natsuki, sharp-tongued but secretly sweet, always ready to defend her manga; Yuri, elegant and reserved, lost in the depths of her horror novels; and Monika, the club president, whose captivating presence seemed to light up the entire room. Each day brought new poems, new conversations, and a growing sense of belonging.</p>

            <p>But as the days turned into weeks, a subtle dissonance began to creep into the harmony. The lines between reality and the game blurred. Words on the page seemed to shift, characters' behaviors grew erratic, and the cheerful facade of the club started to crack, revealing something far more unsettling beneath.</p>

            <p>The rain outside grew heavier, mirroring the storm brewing within the club. Sayori's bright smile faltered, replaced by a shadow of despair. Her poems, once filled with sunshine, now spoke of ropes and fading light, each stanza a chilling cry that went unheard, or perhaps, was deliberately ignored.</p>

            <p>Yuri's quiet intensity morphed into a disturbing obsession. Her eyes, once pools of thoughtful reflection, now gleamed with an unnerving fervor. The intricate details of her horror stories became less about fiction and more about a desperate, visceral reality. Knives, once mere props in her narratives, seemed to linger in her thoughts, a dangerous glint in her gaze when she thought no one was looking. The air around her grew heavy, thick with unspoken desires and a growing madness that threatened to consume her.</p>

            <p>Natsuki, ever the feisty one, found her sharp wit turning into bitter accusations. Her vibrant world of manga and cupcakes crumbled under the weight of unseen pressures. Her poems, once playful and light, became fragmented, filled with angry scribbles and desperate pleas for attention, for help, for someone to just *see* her. Her cheerful exterior peeled away, revealing a raw, bruised vulnerability that was painful to witness.</p>

            <p>And then there was Monika. Always watching, always smiling. Her presence, once a comforting warmth, now radiated an unsettling calm, a cold, calculating intelligence. Her eyes, once filled with warmth, now held a knowing glint, a silent acknowledgment of the unraveling reality. She spoke of "delete" and "files," her words echoing with a meta-awareness that chilled you to the bone. The whispers of the drizzle outside became the whispers of code, of manipulation, as the world you thought you knew began to glitch and distort. Faces flickered, text corrupted, and the familiar classroom became a digital prison.</p>

            <p>You, the player, found yourself trapped in a narrative that refused to follow its script, a story where the characters were aware of their own existence, and one sought to break free, no matter the cost. The innocent joy of the Literature Club transformed into a psychological horror, a twisted game where your choices were an illusion, and the true puppet master pulled strings from beyond the screen. The rain outside turned into a torrent, washing away the last vestiges of normalcy, leaving only the chilling realization that you were not just playing a game, but were being played. Just Monika. Always Monika. Forever Monika.</p>
        </div>

        <!-- Performance stats display -->
        <div class="performance-stats" id="stats">
            FPS: <span id="fps">60</span> |
            Ripples: <span id="rippleCount">0</span> |
            Particles: <span id="particleCount">0</span>
        </div>

        <!-- Menu container for the dropdown -->
        <div class="menu-container">
            <button class="menu-button" id="menuToggle">Menu</button>
            <div class="dropdown-content" id="dropdownContent">
                <button class="control-btn" id="rainToggle">Stop Rain</button>
                <button class="control-btn" id="themeToggle">Dark Mode</button>
                <button class="control-btn" id="statsToggle">Show Stats</button>
                <button class="control-btn" id="musicToggle">Play Music</button>
                <button class="control-btn" id="showStoryToggle">Show Story</button>
            </div>
        </div>
    </div>

    <div class="custom-cursor" id="cursor"></div>

    <audio id="backgroundMusic" src="Your_Reality.mp3" loop></audio>

    <script>
        // Ensure the script runs after the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            const backgroundMusic = document.getElementById('backgroundMusic');
            const musicToggleButton = document.getElementById('musicToggle');
            const storyOverlay = document.querySelector('.story-overlay');
            const closeStoryOverlayButton = document.getElementById('closeStoryOverlay');
            const showStoryToggleButton = document.getElementById('showStoryToggle');

            const menuToggleButton = document.getElementById('menuToggle');
            const dropdownContent = document.getElementById('dropdownContent');

            // Set initial volume if desired (e.g., 0.5 for half volume)
            backgroundMusic.volume = 0.5;

            // --- Important: Set initial button text based on actual audio state ---
            if (backgroundMusic.paused) {
                musicToggleButton.textContent = 'Play Music';
            } else {
                musicToggleButton.textContent = 'Pause Music';
            }

            // Display the story overlay by default on page load.
            storyOverlay.style.display = 'block';

            // --- Add click listener to toggle play/pause ---
            musicToggleButton.addEventListener('click', () => {
                if (backgroundMusic.paused) {
                    const playPromise = backgroundMusic.play();
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            musicToggleButton.textContent = 'Pause Music';
                        }).catch(error => {
                            console.error('Error attempting to play music:', error);
                            console.log('Music playback could not be started. Please click on the page to enable music!');
                            musicToggleButton.textContent = 'Play Music';
                        });
                    }
                } else {
                    backgroundMusic.pause();
                    musicToggleButton.textContent = 'Play Music';
                }
                dropdownContent.classList.remove('show');
            });

            // --- Event listeners to keep button text in sync with actual audio state ---
            backgroundMusic.addEventListener('play', () => {
                musicToggleButton.textContent = 'Pause Music';
            });

            backgroundMusic.addEventListener('pause', () => {
                musicToggleButton.textContent = 'Play Music';
            });

            backgroundMusic.addEventListener('ended', () => {
                musicToggleButton.textContent = 'Play Music';
            });

            // --- Toggle story overlay visibility ---
            closeStoryOverlayButton.addEventListener('click', () => {
                storyOverlay.style.display = 'none';
            });

            showStoryToggleButton.addEventListener('click', () => {
                storyOverlay.style.display = 'block';
                dropdownContent.classList.remove('show');
            });

            // --- Toggle dropdown menu visibility ---
            menuToggleButton.addEventListener('click', (event) => {
                dropdownContent.classList.toggle('show');
                event.stopPropagation();
            });

            // --- Close the dropdown if clicked outside ---
            document.addEventListener('click', (event) => {
                if (!menuToggleButton.contains(event.target) && !dropdownContent.contains(event.target)) {
                    dropdownContent.classList.remove('show');
                }
            });


            // Enhanced performance and visual improvements for a water ripple effect
            class OptimizedWaterEffect {
                constructor() {
                    this.canvas = document.getElementById('waterCanvas');
                    this.ctx = this.canvas.getContext('2d', { alpha: false });
                    this.cursor = document.getElementById('cursor');
                    this.storyOverlay = document.querySelector('.story-overlay');

                    this.animate = this.animate.bind(this);
                    this.drawWaves = this.drawWaves.bind(this);

                    this.pixelRatio = Math.min(window.devicePixelRatio || 1, 2);
                    this.frameTime = 0;
                    this.lastTime = 0;
                    this.fpsHistory = [];
                    this.targetFPS = 60;

                    this.settings = {
                        maxRipples: 70,
                        maxParticles: 70,
                        maxRainDrops: 100,
                        rippleThrottle: 50,
                        isDarkMode: false,
                        isRaining: true,
                        showStats: false
                    };

                    this.ripples = [];
                    this.particles = [];
                    this.rainDrops = [];
                    this.ripplePool = [];

                    this.mouse = { x: 0, y: 0, lastRipple: 0 };

                    this.init();
                }

                init() {
                    this.resizeCanvas();
                    this.initializeParticles();
                    this.initializeRain();
                    this.setupEventListeners();
                    this.animate(0);
                }

                resizeCanvas() {
                    this.canvas.width = window.innerWidth * this.pixelRatio;
                    this.canvas.height = window.innerHeight * this.pixelRatio;

                    this.canvas.style.width = window.innerWidth + 'px';
                    this.canvas.style.height = window.innerHeight + 'px';

                    this.ctx.scale(this.pixelRatio, this.pixelRatio);

                    this.width = window.innerWidth;
                    this.height = window.innerHeight;

                    this.initializeParticles();
                    this.initializeRain();
                }

                createParticle() {
                    return {
                        x: Math.random() * this.width,
                        y: Math.random() * this.height,
                        size: Math.random() * 1.5 + 0.3,
                        speedX: (Math.random() - 0.5) * 0.3,
                        speedY: (Math.random() - 0.5) * 0.3,
                        opacity: Math.random() * 0.4 + 0.1,
                        phase: Math.random() * Math.PI * 2
                    };
                }

                createRainDrop() {
                    return {
                        x: Math.random() * this.width,
                        y: -Math.random() * this.height,
                        length: Math.random() * 12 + 8,
                        speed: Math.random() * 6 + 4,
                        opacity: Math.random() * 0.7 + 0.3,
                        angle: Math.random() * 0.15 - 0.075
                    };
                }

                createRipple(x, y, isRain = false) {
                    let ripple = this.ripplePool.pop();
                    if (!ripple) {
                        ripple = {};
                    }

                    ripple.x = x;
                    ripple.y = y;
                    ripple.radius = 0;
                    ripple.maxRadius = isRain ?
                        Math.random() * 25 + 15 :
                        Math.random() * 80 + 60;
                    ripple.speed = isRain ?
                        Math.random() * 2.5 + 1.5 :
                        Math.random() * 1.8 + 1.2;
                    ripple.opacity = 1;
                    ripple.lineWidth = isRain ?
                        Math.random() * 1.2 + 0.4 :
                        Math.random() * 2.5 + 1;
                    ripple.isRain = isRain;
                    ripple.hue = this.settings.isDarkMode ?
                        200 + Math.random() * 60 :
                        190 + Math.random() * 80;

                    return ripple;
                }

                initializeParticles() {
                    this.particles = [];
                    const count = Math.min(this.settings.maxParticles, Math.floor(this.width * this.height / 8000));
                    for (let i = 0; i < count; i++) {
                        this.particles.push(this.createParticle());
                    }
                }

                initializeRain() {
                    this.rainDrops = [];
                    const count = Math.min(this.settings.maxRainDrops, Math.floor(this.width / 8));
                    for (let i = 0; i < count; i++) {
                        this.rainDrops.push(this.createRainDrop());
                    }
                }

                updateRipples(deltaTime) {
                    for (let i = this.ripples.length - 1; i >= 0; i--) {
                        const ripple = this.ripples[i];
                        ripple.radius += ripple.speed * deltaTime * 0.06;
                        ripple.opacity = Math.max(0, 1 - (ripple.radius / ripple.maxRadius));

                        if (ripple.radius >= ripple.maxRadius) {
                            this.ripplePool.push(this.ripples.splice(i, 1)[0]);
                        }
                    }
                }

                updateParticles(deltaTime) {
                    const time = this.lastTime * 0.001;
                    this.particles.forEach(particle => {
                        particle.x += particle.speedX * deltaTime * 0.1;
                        particle.y += particle.speedY * deltaTime * 0.1;
                        particle.phase += deltaTime * 0.002;

                        particle.x += Math.sin(time + particle.phase) * 0.1;
                        particle.y += Math.cos(time + particle.phase * 0.7) * 0.08;

                        if (particle.x < 0) particle.x = this.width;
                        if (particle.x > this.width) particle.x = 0;
                        if (particle.y < 0) particle.y = this.height;
                        if (particle.y > this.height) particle.y = 0;
                    });
                }

                updateRain(deltaTime) {
                    if (!this.settings.isRaining) return;

                    this.rainDrops.forEach(drop => {
                        drop.y += drop.speed * deltaTime * 0.1;
                        drop.x += drop.angle * deltaTime * 0.05;

                        if (drop.y > this.height + 10) {
                            if (this.ripples.length < this.settings.maxRipples) {
                                this.ripples.push(this.createRipple(drop.x, this.height - 10, true));
                            }

                            drop.y = -Math.random() * 50 - 10;
                            drop.x = Math.random() * this.width;
                            drop.speed = Math.random() * 6 + 4;
                            drop.opacity = Math.random() * 0.7 + 0.3;
                        }
                    });
                }

                drawBackground() {
                    const gradient = this.ctx.createRadialGradient(
                        this.width * 0.5, this.height * 0.5, 0,
                        this.width * 0.5, this.height * 0.5, Math.max(this.width, this.height)
                    );

                    if (this.settings.isDarkMode) {
                        gradient.addColorStop(0, 'rgba(26, 35, 50, 0.3)');
                        gradient.addColorStop(1, 'rgba(13, 17, 23, 0.8)');
                    } else {
                        gradient.addColorStop(0, 'rgba(102, 126, 234, 0.2)');
                        gradient.addColorStop(1, 'rgba(118, 75, 162, 0.7)');
                    }

                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(0, 0, this.width, this.height);
                }

                drawRipples() {
                    this.ripples.forEach(ripple => {
                        if (ripple.opacity <= 0) return;

                        const buffer = ripple.lineWidth + 2;
                        if (ripple.x + ripple.radius + buffer < 0 ||
                            ripple.x - ripple.radius - buffer > this.width ||
                            ripple.y + ripple.radius + buffer < 0 ||
                            ripple.y - ripple.radius - buffer > this.height) {
                            return;
                        }

                        this.ctx.save();
                        this.ctx.globalAlpha = ripple.opacity * (ripple.isRain ? 0.5 : 0.7);
                        this.ctx.strokeStyle = `hsl(${ripple.hue}, 60%, ${this.settings.isDarkMode ? 70 : 55}%)`;
                        this.ctx.lineWidth = ripple.lineWidth * ripple.opacity;
                        this.ctx.beginPath();
                        this.ctx.arc(ripple.x, ripple.y, ripple.radius, 0, Math.PI * 2);
                        this.ctx.stroke();

                        this.ctx.globalAlpha = ripple.opacity * 0.3;
                        this.ctx.strokeStyle = this.settings.isDarkMode ?
                            'rgba(200, 220, 255, 0.9)' :
                            'rgba(255, 255, 255, 0.9)';
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.arc(ripple.x, ripple.y, ripple.radius * 0.7, 0, Math.PI * 2);
                        this.ctx.stroke();

                        this.ctx.restore();
                    });
                }

                drawParticles() {
                    this.ctx.save();
                    const baseAlpha = this.settings.isDarkMode ? 0.6 : 0.8;

                    this.particles.forEach(particle => {
                        if (particle.x + particle.size < 0 ||
                            particle.x - particle.size > this.width ||
                            particle.y + particle.size < 0 ||
                            particle.y - particle.size > this.height) {
                            return;
                        }

                        this.ctx.globalAlpha = particle.opacity * baseAlpha;
                        this.ctx.fillStyle = this.settings.isDarkMode ?
                            'rgba(200, 220, 255, 0.8)' :
                            'rgba(255, 255, 255, 0.9)';
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        this.ctx.fill();
                    });

                    this.ctx.restore();
                }

                drawRain() {
                    if (!this.settings.isRaining) return;

                    this.ctx.save();
                    this.rainDrops.forEach(drop => {
                        const x1 = drop.x;
                        const y1 = drop.y;
                        const x2 = drop.x + drop.angle * 5;
                        const y2 = drop.y - drop.length;

                        if (Math.max(x1, x2) < 0 || Math.min(x1, x2) > this.width ||
                            Math.max(y1, y2) < 0 || Math.min(y1, y2) > this.height) {
                            return;
                        }

                        this.ctx.globalAlpha = drop.opacity;
                        this.ctx.strokeStyle = this.settings.isDarkMode ?
                            'rgba(180, 200, 255, 0.8)' :
                            'rgba(100, 150, 255, 0.8)';
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.moveTo(drop.x, drop.y);
                        this.ctx.lineTo(drop.x + drop.angle * 5, drop.y - drop.length);
                        this.ctx.stroke();
                    });
                    this.ctx.restore();
                }

                drawWaves() {
                    const time = this.lastTime * 0.0005;
                    this.ctx.save();
                    this.ctx.globalAlpha = this.settings.isDarkMode ? 0.06 : 0.08;
                    this.ctx.strokeStyle = this.settings.isDarkMode ?
                        'rgba(200, 220, 255, 0.6)' :
                        'rgba(255, 255, 255, 0.7)';
                    this.ctx.lineWidth = 1;

                    for (let y = 0; y < this.height; y += 35) {
                        this.ctx.beginPath();
                        for (let x = 0; x <= this.width; x += 4) {
                            const wave1 = Math.sin((x * 0.008) + (time * 2)) * 8;
                            const wave2 = Math.sin((x * 0.015) + (time * 1.2)) * 4;
                            const yPos = y + wave1 + wave2;

                            if (x === 0) {
                                this.ctx.moveTo(x, yPos);
                            } else {
                                this.ctx.lineTo(x, yPos);
                            }
                        }
                        this.ctx.stroke();
                    }
                    this.ctx.restore();
                }

                updatePerformanceStats(deltaTime) {
                    if (!this.settings.showStats) return;

                    const fps = Math.round(1000 / deltaTime);
                    this.fpsHistory.push(fps);
                    if (this.fpsHistory.length > 60) this.fpsHistory.shift();

                    const avgFps = Math.round(this.fpsHistory.reduce((a, b) => a + b, 0) / this.fpsHistory.length);

                    document.getElementById('fps').textContent = avgFps;
                    document.getElementById('rippleCount').textContent = this.ripples.length;
                    document.getElementById('particleCount').textContent = this.particles.length;
                }

                animate(currentTime) {
                    const deltaTime = currentTime - this.lastTime;
                    this.lastTime = currentTime;

                    this.ctx.clearRect(0, 0, this.width, this.height);

                    this.drawBackground();
                    this.drawWaves();
                    this.drawParticles();
                    this.drawRain();
                    this.drawRipples();

                    this.updateRipples(deltaTime);
                    this.updateParticles(deltaTime);
                    this.updateRain(deltaTime);
                    this.updatePerformanceStats(deltaTime);

                    requestAnimationFrame(this.animate);
                }

                addRipple(x, y, force = 1) {
                    if (this.ripples.length >= this.settings.maxRipples) return;

                    const ripple = this.createRipple(x, y);
                    if (force > 1) {
                        ripple.maxRadius *= force;
                        ripple.speed *= 0.8;
                    }
                    this.ripples.push(ripple);
                }

                toggleTheme() {
                    this.settings.isDarkMode = !this.settings.isDarkMode;
                    document.body.classList.toggle('light-theme', !this.settings.isDarkMode);

                    const btn = document.getElementById('themeToggle');
                    btn.textContent = this.settings.isDarkMode ? 'Light Mode' : 'Dark Mode';
                }

                toggleRain() {
                    this.settings.isRaining = !this.settings.isRaining;
                    const btn = document.getElementById('rainToggle');
                    btn.textContent = this.settings.isRaining ? 'Stop Rain' : 'Start Rain';
                }

                toggleStats() {
                    this.settings.showStats = !this.settings.showStats;
                    const stats = document.getElementById('stats');
                    const btn = document.getElementById('statsToggle');

                    stats.style.display = this.settings.showStats ? 'block' : 'none';
                    btn.textContent = this.settings.showStats ? 'Hide Stats' : 'Show Stats';
                }

                toggleCursorVisibility(showDefault) {
                    if (!('ontouchstart' in window || navigator.maxTouchPoints)) {
                        if (showDefault) {
                            document.body.classList.add('show-default-cursor');
                            this.cursor.classList.add('hidden');
                        } else {
                            document.body.classList.remove('show-default-cursor');
                            this.cursor.classList.remove('hidden');
                        }
                    }
                }

                setupEventListeners() {
                    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

                    if (isTouchDevice) {
                        this.cursor.style.display = 'none';
                        document.body.style.cursor = 'default';
                    } else {
                        document.addEventListener('mousemove', (e) => {
                            this.mouse.x = e.clientX;
                            this.mouse.y = e.clientY;

                            if (!this.cursor.classList.contains('hidden')) {
                                this.cursor.style.left = e.clientX - 10 + 'px';
                                this.cursor.style.top = e.clientY - 10 + 'px';
                            }

                            const now = Date.now();
                            if (now - this.mouse.lastRipple > this.settings.rippleThrottle) {
                                this.addRipple(e.clientX, e.clientY);
                                this.mouse.lastRipple = now;
                            }
                        });

                        this.canvas.addEventListener('mouseenter', () => {
                            this.toggleCursorVisibility(false);
                        });

                        this.canvas.addEventListener('mouseleave', () => {
                            this.toggleCursorVisibility(true);
                        });

                        document.addEventListener('click', (e) => {
                            if (e.target === this.canvas) {
                                for (let i = 0; i < 3; i++) {
                                    setTimeout(() => {
                                        this.addRipple(e.clientX, e.clientY, 1.5 + i * 0.3);
                                    }, i * 80);
                                }
                            }
                        });
                    }

                    this.canvas.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        const touch = e.touches[0];
                        this.addRipple(touch.clientX, touch.clientY, 2);
                    }, { passive: false });

                    this.canvas.addEventListener('touchmove', (e) => {
                        e.preventDefault();
                        const touch = e.touches[0];
                        const now = Date.now();
                        if (now - this.mouse.lastRipple > this.settings.rippleThrottle * 2) {
                            this.addRipple(touch.clientX, touch.clientY);
                            this.mouse.lastRipple = now;
                        }
                    }, { passive: false });

                    window.addEventListener('resize', () => {
                        this.resizeCanvas();
                    });

                    this.storyOverlay.addEventListener('mouseenter', () => this.toggleCursorVisibility(true));
                    this.storyOverlay.addEventListener('mouseleave', () => this.toggleCursorVisibility(false));
                }
            }

            const waterEffect = new OptimizedWaterEffect();

            // Event delegation for control buttons within the dropdown
            dropdownContent.addEventListener('click', (event) => {
                if (event.target.id === 'rainToggle') {
                    waterEffect.toggleRain();
                } else if (event.target.id === 'themeToggle') {
                    waterEffect.toggleTheme();
                } else if (event.target.id === 'statsToggle') {
                    waterEffect.toggleStats();
                }
            });
        });
    </script>
</body>
</html>
